# -*- coding: utf-8 -*-
"""OCR.ipynb

Automatically generated by Colaboratory.

# Preparing the Dataset

Preprocessing the screenshots from phone (Cropping, resizing, labelling, etc)

{Change this block according to the specific requirement}
"""

import numpy as np
import cv2
import os

path = "/content/drive/My Drive/Projects/OCR/"
f = False
inImgSize = 40    #The model will work on images of a particular size (40*40 here)

lut = open(F"{path}yLog.txt").readlines()
keys, values = [], []
for i in lut:
  j, k = i.split("~")
  keys.append(j)
  values.append(int(k.rstrip()))
lut = dict(zip(keys, values))

for i in os.listdir(F"{path}Images/"):   #iterating over different images and adding them to image array
  #Resizing the image to inImgSize*inImgSize
  image = cv2.imread(F"{path}Images/{i}", 0)
  xTemp = cv2.resize(image, (inImgSize, inImgSize), interpolation = cv2.INTER_AREA)

  num = log[i]   #Getting labels
  yTemp = np.array([num])
  y = np.append(y, yTemp, axis=0) if f else yTemp   #Appending yTemp to the label array

  x = np.append(x, [xTemp], axis=0) if f else [xTemp]
  f = True

"""Saving the data and labels into binary npy files"""

np.save(F"{path}data.npy", x)
np.save(F"{path}labels.npy", y)

"""Verifying the labels corresponding to images"""

from matplotlib.pyplot import imshow

index = 13
print(y[index])
imshow(x[index], cmap="Greys")

"""# Building the Model

Loading the data and splitting 80% for training and 20% for testing
"""

import numpy as np

x = np.load(F"{path}data.npy")
y = np.load(F"{path}labels.npy")

(xTrain, xTest), (yTrain, yTest) = (x[:60], x[60:]), (y[:60], y[60:])   #Total images = 90

"""Visualizing images and their corresponding labels"""

from matplotlib.pyplot import imshow

index = 55
print(yTrain[index])
imshow(xTrain[index], cmap="Greys")

"""Reshaping (since Keras API requires a 4-dims numpy array) and Normalizing (always required in neural network models)"""

xTrain = xTrain.reshape(xTrain.shape[0], inImgSize, inImgSize, 1)
xTest = xTest.reshape(xTest.shape[0], inImgSize, inImgSize, 1)
inputShape = (inImgSize, inImgSize, 1)

#For precision after normalization
xTrain = xTrain.astype("float32")
xTest = xTest.astype("float32")

xTrain /= 255
xTest /= 255

print("xTrain shape:", xTrain.shape)
print("Number of images in xTrain", xTrain.shape[0])
print("Number of images in xTest", xTest.shape[0])

"""Creating a keras model and add layers to it"""

import tensorflow as tf
from keras.models import Sequential
from keras.layers import Dense, Conv2D, Dropout, Flatten, MaxPooling2D

model = Sequential()
model.add(Conv2D(inImgSize, kernel_size=(3,3), input_shape=inputShape))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Flatten())
model.add(Dense(128, activation=tf.nn.relu))
model.add(Dropout(0.2))
model.add(Dense(14,activation=tf.nn.softmax))

"""Compiling and Fitting the model"""

model.compile(optimizer="adam", 
              loss="sparse_categorical_crossentropy", 
              metrics=["accuracy"])
model.fit(x=xTrain,y=yTrain, epochs=10)

"""Evaluating the model"""

model.evaluate(xTest, yTest)

"""Visualizing the model's predictions"""

index = 19
imshow(x[index].reshape(inImgSize, inImgSize), cmap="Greys")
pred = model.predict(x[index].reshape(1, inImgSize, inImgSize, 1))
print(pred.argmax())

"""Saving the model to drive"""

model.save(F"{path}OCRModel.h5")

"""Credit to [Orhan Gazi Yalçın](https://towardsdatascience.com/@oyalcin) for his article [Image Classification in 10 Minutes with MNIST Dataset](https://https://towardsdatascience.com/image-classification-in-10-minutes-with-mnist-dataset-54c35b77a38d) over at Medium

# Using the model for custom predictions

Loading the saved model from drive
"""

from keras.models import load_model
import tensorflow as tf
from keras.utils.generic_utils import CustomObjectScope

with CustomObjectScope({"softmax_v2": tf.nn.softmax}):    #Maybe due to mismatch between TF2.0 and keras
    model = load_model(F"{path}OCRModel.h5")

"""Loading the desired image and running the model over it

{Change this block according to the specific requirement}
"""

image = cv2.imread(F"{path}Images/{i}", 0)
#Resizing Image
h, w = image.shape
if h <= inImgSize and w <= inImgSize:
  image = np.full((inImgSize, inImgSize), (0,), dtype = np.uint8)
  nw = (inImgSize - w)//2
  nh = (inImgSize - h)//2
  image[nh: nh+h, nw: nw+w] = image
else:
  image = cv2.resize(image, (inImgSize, inImgSize), interpolation = cv2.INTER_AREA)

pred = model.predict(image.reshape(1, inImgSize, inImgSize, 1))
print(pred.argmax())